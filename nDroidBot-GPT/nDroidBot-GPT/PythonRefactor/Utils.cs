using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;
using System.Security.Cryptography;

namespace nDroidBot_GPT.PythonRefactor
{
    public static class Utils
    {
        // Logcat regex, which will match the log message generated by `adb logcat -v threadtime`
        private static readonly Regex LogcatThreadtimeRe = new Regex(@"^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+" +
            @"(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$", RegexOptions.Compiled);

        // Lazy property attribute
        public static Func<T> LazyProperty<T>(Func<T> func)
        {
            var cache = new Lazy<T>(func);
            return () => cache.Value;
        }

        public static Dictionary<string, object> ParseLog(string logMsg)
        {
            // Parse a logcat message in threadtime format
            var match = LogcatThreadtimeRe.Match(logMsg);
            if (!match.Success)
            {
                return null;
            }

            var logDict = new Dictionary<string, object>
        {
            { "pid", match.Groups["pid"].Value },
            { "tid", match.Groups["tid"].Value },
            { "level", match.Groups["level"].Value },
            { "tag", match.Groups["tag"].Value },
            { "content", match.Groups["content"].Value }
        };

            // Date and time manipulation
            var date = match.Groups["date"].Value;
            var time = match.Groups["time"].Value;
            var datetimeStr = $"{DateTime.Now.Year}-{date} {time}";
            logDict["datetime"] = DateTime.ParseExact(datetimeStr, "yyyy-MM-dd HH:mm:ss.fff", null);

            return logDict;
        }

        public static List<string> GetAvailableDevices()
        {
            // Get a list of device serials connected via adb
            var devices = new List<string>();
            var processStartInfo = new System.Diagnostics.ProcessStartInfo
            {
                FileName = "adb",
                Arguments = "devices",
                RedirectStandardOutput = true,
                UseShellExecute = false
            };

            using (var process = System.Diagnostics.Process.Start(processStartInfo))
            using (var reader = process.StandardOutput)
            {
                var output = reader.ReadToEnd();
                var lines = output.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

                foreach (var line in lines.Skip(1))
                {
                    var segments = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    if (segments.Length == 2 && segments[1] == "device")
                    {
                        devices.Add(segments[0]);
                    }
                }
            }

            return devices;
        }

        public static T WeightedChoice<T>(Dictionary<T, double> choices)
        {
            var total = choices.Values.Sum();
            var rand = new Random();
            var r = rand.NextDouble() * total;

            double upto = 0;
            foreach (var choice in choices)
            {
                if (upto + choice.Value >= r)
                {
                    return choice.Key;
                }
                upto += choice.Value;
            }
            return default; // Default in case of an error
        }

        public static bool? SafeReMatch(Regex regex, string content)
        {
            // Safe regex matching function
            if (regex == null || content == null)
                return null;

            return regex.IsMatch(content);
        }

        public static string Md5(string inputStr)
        {
            // MD5 hash function
            using (var md5 = MD5.Create())
            {
                var hashBytes = md5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(inputStr));
                return BitConverter.ToString(hashBytes).Replace("-", "").ToLower();
            }
        }
    }

}
